(* Common types used by representations *)
open Loc

type err =
  { msg : string
  ; hint : string option
  ; loc : span
  }
  [@@deriving show]

let err msg loc =
  { msg; hint = None; loc }

let err_ret msg loc =
  Error (err msg loc)

let with_hint hint err =
  { err with hint = Some hint }

let from_result = function
| Ok x -> x
| Error (msg, loc) -> err msg loc

type lit =
  | LUnit
  | LBool  of bool
  | LInt   of int
  | LFloat of float
  | LStr   of string
  | LSym   of string
  [@@deriving show]

and pattern =
  | PatLit of lit
  [@@deriving show]

and bin =
  | Add | Sub | Mul | Div | Mod
  | Eq  | Neq | Lt  | Lte | Gt | Gte
  | And | Or
  | Cons
  [@@deriving show]

and typ =
  | TyConst of string
  | TyTuple of typ * typ
  | TyArrow of typ * typ
  | TyConstructor of string * typ
  | TyVar of string (* Generated by inference *)
  | TyAny (* Only used by compiler magics *)
  [@@deriving show]

let string_of_lit = function
  | LUnit -> "ok" (* Assuming this is Erlang's unit expression *)
  | LBool b -> string_of_bool b
  | LInt i -> string_of_int i
  | LFloat f -> string_of_float f
  | LStr s -> "\"" ^ s ^ "\""
  | LSym s -> s

let string_of_bin = function
  | Add -> "+"
  | Sub -> "-"
  | Mul -> "*"
  | Div -> "/"
  | Mod -> "rem"
  | Eq -> "=="
  | Neq -> "/="
  | Lt -> "<"
  | Lte -> "<="
  | Gt -> ">"
  | Gte -> ">="
  (* Short-circuiting *)
  | And -> "andalso"
  | Or -> "orelse"
  | Cons -> "|"

let rec string_of_typ = function
  | TyAny -> "_"
  | TyConst s -> s
  | TyTuple (a, b) -> string_of_typ a ^ " * " ^ string_of_typ b
  | TyArrow (a, b) -> string_of_typ a ^ " -> " ^ string_of_typ b
  | TyConstructor (f, b) -> string_of_typ b ^ " " ^ f
  | TyVar s -> s
